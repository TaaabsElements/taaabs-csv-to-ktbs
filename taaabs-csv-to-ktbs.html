<link rel="import" href="../taaabs-themes/taaabs-dark-theme.html">
<dom-module id="taaabs-csv-to-ktbs">
  <template>

    <style include="taaabs-dark-theme"></style>
    <style>

		.progressContainer{
			display: block;
			width:1000px;
			margin: 0 auto;
			height: 30px;
			border: solid 1px white;
		}

		.progressContainer > div{
			width: 0px;
			height: 100%;
			background-color: #21b2a6;
		}

    /*/////////*/
    /* SPINNER */
    /*/////////*/

    #spinner{
      opacity: 0;
      padding-top: 1em;


      -webkit-transition: opacity 0.25s ease-in-out;
      -moz-transition: opacity 0.25s ease-in-out;
      -o-transition: opacity 0.25s ease-in-out;
      -ms-transition: opacity 0.25s ease-in-out;
    }

    .spinner {
      margin: 0 auto;
      width: 50px;
      height: 40px;
      text-align: center;
      font-size: 10px;
      display: block;
    }

    .spinner > div {
      /*background-color: #ed4933;*/
      background-color: #21b2a6;
      height: 100%;
      width: 6px;
      display: inline-block;

      -webkit-animation: sk-stretchdelay 1.2s infinite ease-in-out;
      animation: sk-stretchdelay 1.2s infinite ease-in-out;
    }

    .spinner .rect2 {
      -webkit-animation-delay: -1.1s;
      animation-delay: -1.1s;
    }

    .spinner .rect3 {
      -webkit-animation-delay: -1.0s;
      animation-delay: -1.0s;
    }

    .spinner .rect4 {
      -webkit-animation-delay: -0.9s;
      animation-delay: -0.9s;
    }

    .spinner .rect5 {
      -webkit-animation-delay: -0.8s;
      animation-delay: -0.8s;
    }

    @-webkit-keyframes sk-stretchdelay {
      0%, 40%, 100% { -webkit-transform: scaleY(0.4) }
      20% { -webkit-transform: scaleY(1.0) }
    }

    @keyframes sk-stretchdelay {
      0%, 40%, 100% {
        transform: scaleY(0.4);
        -webkit-transform: scaleY(0.4);
      }  20% {
        transform: scaleY(1.0);
        -webkit-transform: scaleY(1.0);
      }
    }

    </style>

    <div style="width: 1000px; margin: 0 auto;">
      <taaabs-csv-collector-steps id="tccs" steps=[[_steps]]></taaabs-csv-collector-steps>
    </div>

    <iron-pages selected="{{_pageIndex}}" style="margin-top: 30px;">

      <div style="max-width: 1000px; margin: 0 auto">
        <taaabs-csv-collector-files id="tccf" files="{{files}}" file-reader={{_filereader}}></taaabs-csv-collector-files>
      </div>

      <div  style="max-width: 1000px; margin: 0 auto">
        <taaabs-csv-collector-configs id="tccc" csv-schemas="[[csvSchemas]]">
        </taaabs-csv-collector-configs>
      </div>

      <div style="max-width: 1000px; margin: 0 auto">


        <div style="display:table; table-layout:fixed; width: 100%">
          <div style="display:table-cell; width: 30%; border-right: solid 1px grey; padding:1em;">
            <div style="display:block; max-height: 300px; min-height: 100px;">
              <template is="dom-repeat" items="{{files}}">
                <div style="padding-bottom:1em;">
                  {{item.name}}
                </div>
              </template>
            </div>
          </div>
          <div style="display:table-cell; width: 30%;border-right: solid 1px grey;padding: 1em;">
            <div id="upload" class="button" style="display:block;" on-click="_startUpload">
              UPLOAD
            </div>
            <div id="spinner">
              <div class="spinner">
                <div class="rect1"></div>
                <div class="rect2"></div>
                <div class="rect3"></div>
                <div class="rect4"></div>
                <div class="rect5"></div>
              </div>
            </div>
          </div>
          <div style="display:table-cell; width: 30%; padding: 1em;">
            <div style="display:block; max-height: 300px">
              <template is="dom-repeat" items="{{_tracesCreatedUrl}}">
                <div style="padding-bottom:1em;">
                  {{item}}
                </div>
              </template>
            </div>
          </div>
        </div>

      	<p>Current file status : {{currentFile.name}}</p>
      	<div class="progressContainer">
      		<div id="fileProgress">
      		</div>
      	</div>


      </div>

      <div>
        UPLOAD DONE
      </div>

      </iron-pages>
  </template>
  <script>


    /**
    * `taaabs-csv-to-ktbs` is graphical element in which the user can upload a trace csv file according to a trace model previously edited.
    *
    * ### Example :
    *
    *     <taaabs-csv-to-ktbs id="csvToKtbs"
    *                    base="[[_base]]"
    *                    csv-schemas="{{csvSchemas}}"
    *                    files="{{files}}"
    *                    csv-schema="{{csvSchema}}"
    *                    language="{{language}}">
    *     </taaabs-csv-to-ktbs>
    *
    *
    * @element taaabs-csv-to-ktbs
    */
  	Polymer({
      is: 'taaabs-csv-to-ktbs',

      properties: {

        _steps: {
          type: Array,
          value: [
            {
                'name':'file selection',
                'state':'current'
            },
            {
                'name':'import-config selection',
                'state':'undone'
            },
            {
                'name':'trace upload',
                'state':'undone'
            }
          ]
        },

      	/**
        * Traces files opened by the user.
        *
        * @attribute files
        * @type Array
        */
        files: {
          type: Array,
          notify: true,
          value: function(){
            return [];
          },
        },

        /**
        * Current csv schema used/edited by the user.
        *
        * @attribute csvSchema
        * @type Object
        */
        csvSchema: {
          type: Object,
          notify: true,
          value: function(){
            return {};
          }
        },

        _tracesCreatedUrl:{
          type: Array,
          notify: true,
          value: []
        },

        /**
        * Array of all existing csv schemas on the current base.
        *
        * @attribute csvSchemas
        * @type Array
        */
        csvSchemas: {
          type: Array,
          notify: true,
          value: function(){
            return [];
          }
        },

        base: {
          type: Object,
          notify: true,
          value: function(){
            return {};
          }
        },

        _pageIndex: {
          type: Number,
          notify: true,
          value: function(){
            return 0;
          }
        },

        _temporaryAttributes: {
          type: Array,
          notify: true,
          value: []
        },

        /**
        * Localization object.
        *
        * @attribute _i18n
        * @type Object
        */
        _i18n: {
            type: Object,
            value: function(){
              return {}
            },
            notify: true
        },

        /**
        * Localization.
        * fr, en.
        *
        * @attribute language
        * @type String
        */
        language: {
            type: String,
            notify: true,
            observer: "_languageChanged"
        }
      },

      ready: function(){
        // Create a pointer to `this` for later.
        var that = this;

        this.$.tccs.addEventListener('STEP_CLICKED', function(e){
          that._goToPage(e.detail.index);
        })
        this.$.tccf.addEventListener('FILES_SELECTED', function(){
          that._goToPage(1);
        });
        this.$.tccc.addEventListener('CREATE_SCHEMA', function(e){
          alert('You cannot create at the point of the upload process. ');
        })
        this.$.tccc.addEventListener('SELECT_SCHEMA', function(e){
          that.set('csvSchema', that.csvSchemas[e.detail.index]);
          that._goToPage(2);
        })
      },

      /**
      * Triggered when the language option is changed.
      * Switches every text into the new language.
      *
      * @method _languageChanged
      */
      _languageChanged: function(){
        for(var prop in this._i18n) {
          var tmp = "_i18n."+prop+".default";
          this.set(tmp, this._i18n[prop][this.language]);
        }
      },

      _goToPage: function( index ){

        this.set('_pageIndex',index);

        for(var i = 0; i < this._steps.length; i++){
          if( i < index ){
            this.splice('_steps',i,1,{'name':this._steps[i].name,
            'state':'done'});
          }
          else if( i > index ){
            this.splice('_steps',i,1,{'name':this._steps[i].name,
            'state':'undone'});
          }
          else{
            this.splice('_steps',i,1,{'name':this._steps[i].name,
            'state':'current'});
          }
        }
      },


      _startUpload: function(){


      	this.traceCount = 0;
      	this.fileIndex = 0;

      	var that = this;

      	// TODO A virer quand samotrace ira mieux.

        this.$.upload.style.opacity = 0.37;
        this.$.upload.style.pointerEvents = "none";
        this.$.spinner.style.opacity = 1;


        that.base.list_computed_traces()
            .then( function( listTraces ){
              that.traceCount = listTraces.length;

              that._createTrace();
            })
            .catch( function(err){
              console.log(err);
            });

      },

      _createTrace: function(){

      	var that = this;

      	that.$.fileProgress.style.width = '0px';

      	that.traceCount = that.traceCount + 1;
      	that.obselIndex = 0;

      	if(that.fileIndex < that.files.length){

      		that.currentFile = that.files[ that.fileIndex ];

      		that.base.create_stored_trace(
      			't'+that.traceCount,
      			that.csvSchema.id,
      			null,
      			null,
      			'trace from '+that.currentFile.name,
      			'This trace was generated with a csv collector, from the file '+that.currentFile.name+'.')
      			.then( function(trace){

      				that.currentTrace = trace;
      				that.sliceIndex = 1;
      				that.sliceCount = that._filereader.getSlices( that.fileIndex );

      				that._uploadTrace();
      			})
      			.catch( function(err){
      				console.log(err);
      			})

      	}
      	else{
      		that._pageIndex = 3;
      	}

      },

      _uploadTrace: function(){

      	console.log('_uploadTrace entered' );

      	var that = this;

      	that.parsedData = [];
      	that.remains = "";

      	var callbackObject = {
      	  onload: function(evt){
            that._startParsing( evt.target.result );
          },
          onerror: function(evt){ },
          onprogress: function(evt){ }
      	}

      	that._filereader.getSlice(that.fileIndex, that.sliceIndex, callbackObject);
      },

      _startParsing: function( result ){

      	console.log('_startParsing entered' );

      	var that = this;

      	var worker = new Worker( that.resolveUrl('csvToArray.js') );
      	worker.addEventListener('message', function(e) {
          that.parsedData = e;
          worker.terminate();
          that._postSlice();
        }, false);

        var sData =  that.remains + result;

        worker.postMessage({strData: sData, strDelimiter: that.csvSchema.separator});

      },

      _postSlice: function(){

      	console.log('_postSlice entered' );

      	var e = this.parsedData;
      	this.remains = "";

      	for(var i = 0 ; i < e.data[e.data.length-1].length - 1;i++){
          this.remains = this.remains+e.data[e.data.length-1][i]+this.csvSchema.separator;
        }

        this.remains = this.remains+e.data[e.data.length-1][e.data[e.data.length-1].length-1];


        this.partIndex = 0;
        if(this.sliceIndex === 1 && this.csvSchema.columnHeader)
          this.partIndex = 1;
        this._postPartOfSlice();

      },

      _postPartOfSlice: function(){

      	console.log('_postPartOfSlice entered' );

      	var e = this.parsedData;
      	var obsels = [];
      	var i = this.partIndex;

      	while( i < e.data.length && i < (this.partIndex + 500)){

          var push = true;

      		var tmp = {
	            "@id": "o"+this.obselIndex,
	            "subject": "obsel of trace ",
	          };

	        var typeObject = null;

          if( e.data[i].length !== this.csvSchema.columns.length )
            push = false;

          else{
  	        if( this.csvSchema.typeColumn !== -1 ){
  	        	typeObject = this._findTypeObject( e.data[i][this.csvSchema.typeColumn] );
              if( typeObject !== null && typeObject.enabled )
  	        	  tmp['@type'] = 'm:'+typeObject.name;
              else {
                push = false;
              }
  	        }
  	        else{
  	        	tmp['@type'] = 'm:defaultType';
  	        }

  	        for(var j = 0; j < e.data[i].length; j++){
  	        	if( typeObject === null){
  	        		tmp[ 'm:'+this.csvSchema.columns[j].name ] = e.data[i][j];
  	        	}
  	        	else{
  	        		if( typeObject.attributes[j].enabled ){
                  if( typeObject.attributes[j].datatype === 'json'){
                    this._getAttributesFromJSON(tmp, typeObject.attributes[j].name, e.data[i][j]);
                  }
                  else{
                    tmp[ 'm:'+typeObject.attributes[j].name ] = e.data[i][j];
                  }
  	        		}
  	        	}
  	        }

  	        if( this.csvSchema.time.beginColumn !== -1 ){

  	        	tmp["begin"] = this._getDate( this.csvSchema.time.beginFormat, e.data[i][this.csvSchema.time.beginColumn]);

  	        	if( this.csvSchema.time.endColumn !== -1 ){

  	        		tmp["end"] = this._getDate( this.csvSchema.time.endFormat, e.data[i][this.csvSchema.time.endColumn]);

  	        	}
  	        	else{

  	        		tmp["end"] = tmp["begin"];

  	        	}

  	        }
  	        else{

  	        	tmp["begin"] = this.obselIndex;
  	        	tmp["end"] = this.obselIndex;

  	        }
          }

	        this.obselIndex = this.obselIndex + 1;
	        i = i + 1;
          if(push)
	         obsels.push(tmp);

      	}

      	this.partIndex = i;

      	var that = this;

        console.log( obsels );

      	this.currentTrace.create_obsels( obsels )
          .then(function(data){
            that._postPartOfSliceSuccess();
          })
          .catch(function(data){
            console.log(data);
            that._postPartOfSliceError();
          });

      },

       _getAttributesFromJSON: function(tmpObsel, attributeBase, data){

        var json = null;
        var atts = [];

        function process (base, obj) {

          for(var prop in obj){

            if(typeof obj[prop] === "object"){
              process(base+'_'+prop, obj[prop]);
            }
            else{
              var attName = base+'_'+prop;
              var objTmp = {};
              objTmp.attName = attName ;
              objTmp.attValue = obj[prop];
              atts.push(objTmp);
            }

          }

        }


        try {
          json = JSON.parse(data);
        }
        catch (e) {
          return null;
        }

        process( attributeBase , json );

        for(var i = 0 ; i < atts.length; i++){
          this._registerAttribute( atts[i].attName, tmpObsel );
          var att4obsel = 'm:'+atts[i].attName;
          tmpObsel[att4obsel] = atts[i].attValue;
        }

      },

      _registerAttribute: function(attName, tmpObsel){
        var exists = false;

        var obselType = tmpObsel['@type'].replace('m:','');
        obselType = '#' + obselType;

        for(var j = 0; j < this._temporaryAttributes.length; j++){

          if( this._temporaryAttributes[j]['@id'] === attName ){
            exists = true;
            var typeSet = false;
            for(var k = 0; k <this._temporaryAttributes[j]['hasAttributeObselType'].length; k++){
              if( this._temporaryAttributes[j]['hasAttributeObselType'][k] === obselType ){
                typeSet = true;
              }
            }
            if(!typeSet){
              this._temporaryAttributes[j]['hasAttributeObselType'].push(obselType);
            }
          }
        }
        if( !exists ){
          var attr = {
            "@id": '#'+attName,
            "@type": "AttributeType" ,
            "hasAttributeObselType": [obselType] ,
            "hasAttributeDatatype": ['xsd:string']
          }
          this.push('_temporaryAttributes',attr);
        }

      },



      _postPartOfSliceSuccess: function(){

        var that = this;

      	console.log('_postPartOfSliceSuccess entered' );

        if( this.partIndex < this.parsedData.data.length - 1 ){
          this.$.fileProgress.style.width =
            ( ( ( this.sliceIndex - 1 ) * ( 1000 / this.sliceCount ) ) + ( ( ( 1000 / this.sliceCount ) / this.parsedData.data.length ) * this.partIndex ) ) + 'px';



          console.log('part' + this.partIndex + " sent  ET "+this.$.fileProgress.style.width);
          this._postPartOfSlice();
        }
        else{
          this.sliceIndex = this.sliceIndex + 1;
          if(this.sliceIndex <= this.sliceCount ){
          	var callbackObject = {
	      	  onload: function(evt){
	            that._startParsing(evt.target.result);
	          },
	          onerror: function(evt){ },
	          onprogress: function(evt){ }
	      	}

      		this._filereader.getSlice(
              this.fileIndex,
              this.sliceIndex,
              callbackObject
            );
          }

          else{
            this.fileIndex = this.fileIndex + 1;

            this.push('_tracesCreatedUrl', this.currentTrace.uri);

            this._createTrace();
          }
        }
      },

      _postPartOfSliceError: function(){
        console.log("postPartOfSlice Failed");
        this.fileIndex = this.fileIndex + 1;

        this.push('_tracesCreatedUrl', this.currentTrace.uri);

        this._createTrace();
      },

      _findTypeObject: function( title ){
      	for(var i = 0; i < this.csvSchema.typesObjects.length; i++){
      		if( this.csvSchema.typesObjects[i].title === title ){
      			return this.csvSchema.typesObjects[i];
      		}
      	}
      	return null;
      },

      _getDate: function(format, data){

        function getElement(format, symbol, data, match){
          var index = format.search(symbol);
          if(match != null && index > -1 && index < match.length)
            return parseInt( match[index] );
          else
            return 0;
        }

        var match = data.match(/\d+/g);

        var month = getElement(format, 'M', data, match);
        var date = new Date(getElement(format, 'Y', data, match),month,getElement(format, 'D', data, match) );
        date.setHours(getElement(format, 'H', data, match));
        date.setMilliseconds(getElement(format, 's', data, match));
        date.setMinutes(getElement(format, 'm', data, match));
        date.setSeconds(getElement(format, 'S', data, match));

        return date.getTime();
      },



    });
  </script>
</dom-module>
